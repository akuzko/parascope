# Parascope

[![Build Status](https://secure.travis-ci.org/akuzko/parascope.png)](http://travis-ci.org/akuzko/parascope)

Because `periscope` is already taken.

--

This gem provides a `Parascope::Query` class with a declarative and convenient API
to build scopes (ActiveRecord relations or arbitrary objects) dynamically, based
on parameters passed to query object on initialization.

## Installation

Add this line to your application's Gemfile:

```ruby
gem 'parascope'
```

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install parascope

## Usage

Despite the fact `parsacope` was intended to help building ActiveRecord relations
via scopes or query methods, it's usage is not limited to ActiveRecord cases and
may be used with any arbitrary classes and objects. In fact, the only gem's dependency
is `hashie`, and for development and testing, `OpenStruct` instance is used as a
generic scope object. However, ActiveRecord examples should illustrate gem's usage
in the best way.

### API

`parascope` provides `Parascope::Query` class, descendants of which should declare
scope manipulations using `query_by`, `sift_by` and other class methods bellow.

#### Class Methods

- `query_by(*presence_fields, **value_fields, &block)` declares a scope-generation query
  block that will be executed if, and only if all values of query params at the keys of
  `presence_fields` are present in activesupport's definition of presence and all value
  fields are present in query params as is. The block is executed in context of query
  object. All values of specified params are yielded to the block. If the block
  returns a non-nil value, it becomes a new scope for following processing. Of course,
  there can be multiple `query_by` block definitions. Optionally, `:index` option
  may be passed to control query blocks application order.

- `sift_by(*presence_fields, **value_fields, &block)` method is used to hoist sets of
  query definitions that should be applied if, and only if, all specified values
  match criteria in the same way as in `query_by` method. Just like `query_by` method,
  values of specified fields are yielded to the block. Such `sift_by` definitions
  may be nested in any depth.

- `base_scope(&block)` method is used to define a base scope as a starting point
  of scope-generating process. If this method is called from `sift_by` block,
  top-level base scope is yielded to the method block. Note that `base_scope` will
  not be called if query is initialized with a given scope.

- `defaults(hash)` method is used to declare default query params that are reverse
  merged with params passed on query initialization. When used in `sift_by` block,
  hashes are merged altogether.

- `guard(&block)` defines a guard instance method block (see instance methods
  bellow). All such blocks are executed before query object resolves scope via
  `resolve_scope` method.

#### Instance Methods

- `initialize(params, scope: nil, **attributes)` initializes a query with `params`,
  an optional scope (that if passed, is used instead of `base_scope`). All additionally
  passed options are accessible via reader methods in query blocks and elsewhere.

- `params` returns a parameters passed in initialization. Is a `Hashie::Mash` instance,
  thus, values can be accessible via reader methods.

- `[](key)` delegates to query `params` for slightly easier values access.

- `scope` "current" scope of query object. For an initialized query object corresponds
  to base scope. Primary usage is to call this method in `query_by` blocks and return
  it's mutated version corresponding to passed `query_by` arguments.

- `guard(&block)` executes a passed `block`. If this execution returns falsy value,
  `UnpermittedError` is raised. You can use this method to ensure safety of param
  values interpolation to a SQL string in a `query_by` block for example.

- `resolved_scope(override_params = nil)` returns a resulting scope generated by
  all queries and sifted queries that fit to query params applied to base scope.
  Optionally, additional params may be passed to override the ones passed on
  initialization. It's the main `Query` instance method that returns the sole
  purpose of it's instances.

### Usage example with ActiveRecord Relation as a scope

```ruby
class UserQuery < Parascope::Query
  defaults only_active: true

  base_scope { company.users }

  query_by :only_active do
    scope.active
  end

  query_by :birthdate do |date|
    scope.by_birtdate(date)
  end

  query_by :name do |name|
    scope.where("CONCAT(first_name, ' ', last_name) LIKE ?", "%#{name}%")
  end

  sift_by :sort_column, :sort_direction do |scol, sdir|
    guard { sdir.to_s.downcase.in?(%w(asc desc)) }

    base_scope { |scope| scope.order(scol => sdir) }

    query_by(:sort_direction, sort_column: 'name') do |sdir|
      scope.reorder("CONCAT(first_name, ' ', last_name) #{sdir}")
    end
  end

  sift_by :with_projects do
    base_scope { |scope| scope.joins(:projects) }

    query_by :project_name do |name|
      scope.where(projects: {name: name})
    end
  end

  def users
    @users ||= resolved_scope
  end

  def project_users
    @project_users ||= resolved_scope(with_projects: true)
  end
end

params = {name: 'John', sort_column: 'name', sort_direction: 'DESC', project_name: 'ExampleApp'}

query = UserQuery.new(params, company: some_company)

query.project_users # => this is the same as:
# some_company.users
#   .active
#   .joins(:projects)
#   .where("CONCAT(first_name, ' ', last_name) LIKE ?", "%John%")
#   .where(projects: {name: 'ExampleApp'})
#   .order("CONCAT(first_name, ' ', last_name) DESC")
```

## Development

After checking out the repo, run `bin/setup` to install dependencies. Then, run
`rake spec` to run the tests. You can also run `bin/console` for an interactive
prompt that will allow you to experiment.

## Contributing

Bug reports and pull requests are welcome on GitHub at https://github.com/akuzko/parascope.


## License

The gem is available as open source under the terms of the
[MIT License](http://opensource.org/licenses/MIT).

